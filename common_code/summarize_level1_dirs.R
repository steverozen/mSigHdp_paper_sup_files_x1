# Please run this script from the top directory
top.dir <- "mSigHdp_paper_sup_files_x1"
if (basename(getwd()) != top.dir) {
  stop("Please run from top level directory, ", top.dir)
}

# Install and load dependencies -----------------------------------------------
# if (!requireNamespace("tibble", quietly = TRUE)) {
#  install.packages("tibble")
# }
# Users should know to install packages
require(ICAMS) # v3.0.6
# remotes::install_github("WuyangFF95/SynSigEval", ref = "v0.4.0-branch")
require(SynSigEval) # v0.4.0
require(tibble)


# Conversion from SigPro signatures to ICAMS signatures -----------------------
# Required step because function extract_from_one_seed_summary()
# only accepts ICAMS signature files
#
# These functions CAN deal with VERY LONG path names generated by SigPro

# Function to convert SigPro signatures files into ICAMS format
# Conversion function for ONE data set directory (e.g. "SBS_set1") 
move_sigpro_files_one_dir <- function(a_dir) {
  
  start.here <- file.path(a_dir, "raw_results")
  
  
  # Check whether a_dir contains SBS or indel data sets.
  # This is useful to call different functions to transfrom SigPro catalog.
  flag_indel <- FALSE
  flag_SBS <- FALSE
  if (grepl("indel", basename(a_dir))) {
    # indel_set1, indel_set2
    # indel_set1_down_samp, indel_set2_down_samp
    flag_indel <- TRUE
  }
  if (grepl("SBS", basename(a_dir))) {
    # SBS_*
    # sens_SBS35_*
    flag_SBS <- TRUE
  }
  
  # Skip a_dir is not a folder with indel or SBS data set.
  if ((flag_SBS || flag_indel) == FALSE) {
    message("Skipping ", a_dir, " as it is not a folder for SBS or indel data sets")
    invisible(return(NULL))
  }
  if ((flag_SBS && flag_indel) == TRUE) {
    stop("a_dir cannot be both an SBS and indel data set\n")
  }
  
  # A full directory path, e.g "indel_set1/raw_results/SigProfilerExtractor.results"
  analysis_name <- file.path(a_dir, "raw_results", "SigProfilerExtractor.results")
  if(!dir.exists(analysis_name)) {
    message("\n=====================")
    message("\n=====================")
    message(analysis_name, " does not exist, skipping...")
    invisible(return(NULL))
  }
  
  message("\n=====================")
  message("\n=====================")
  message("Looking for analysis_name=", analysis_name)
  # No need to use "\\." for exact match, as fixed = TRUE is set
  tool_name <- sub(".results", "", basename(analysis_name), fixed = TRUE)
  # dataset_path, e.g indel_set1/raw_results/SigProfilerExtractor.results/"Moderate"
  dataset_paths <- list.files(analysis_name, full.names = TRUE)
  for (dataset_path in dataset_paths) {
    noise_level <- basename(dataset_path)
    if (!noise_level %in% 
        c("Noiseless", "Moderate", "Realistic")) {
      if (dir.exists(dataset_path)) {
        message("\n\n**Skipping directory ", dataset_path, "**\n\n")
      }
      next
    }
    message("Moving into dataset_path=", dataset_path)
    seeds_paths <- 
      list.files(dataset_path, pattern = "seed\\.\\d+", full.names = TRUE)
    
    # Switch SigPro extracted signatures into ICAMS format catalog csv file
    for(seed_path in seeds_paths) {
      # seedInUse e.g. "indel/raw_results/mSigHdp.results/Moderate/seed.528401"
      message("\nMoving into seed_path=", seed_path)
      seedInUse <- sub("seed.", "", basename(seed_path), fixed = TRUE)
      
      # Pass if SigPro raw result folder is absent
      # These raw results are only locally stored 
      # because their path are too long to be pushed to a GitHub repo.
      if (flag_SBS) {
        path_to_check_SBS <- file.path(seed_path, "SBS96")
        if (dir.exists(path_to_check_SBS) == FALSE) {
          message("Skipping seed_path=", seed_path, "\n")
          next
        }
      }
      if (flag_indel) {
        path_to_check_ID <- file.path(seed_path, "ID83")
        if (dir.exists(path_to_check_ID) == FALSE) {
          message("Skipping seed_path=", seed_path, "\n")
          next
        }
      }
      # Copy and reformat files
      if (flag_SBS) cat_type <- "SBS96"
      if (flag_indel) cat_type <- "ID83"
      
      # Convert SigPro-TSV-formatted signatures to ICAMS-CSV format -----------------
      # <seed_path>/SBS96/Suggested_Solution/SBS96_De-Novo_Solution/Signatures
      sig.path <- 
        paste0(seed_path, "/", cat_type, "/Suggested_Solution/",
               cat_type, "_De-Novo_Solution/Signatures/", 
               cat_type, "_De-Novo_Signatures.txt")
      sig.catalog.sp <- utils::read.table(
        sig.path,
        sep = "\t",
        as.is = TRUE,
        header = TRUE)
      # Convert catalog to ICAMS format, using wrapper function
      if (cat_type == "SBS96") {
        sig.catalog <- ICAMS:::MakeSBS96CatalogFromSigPro(sig.catalog.sp)
      } else if (cat_type == "ID83") {
        sig.catalog <- ICAMS:::MakeID83CatalogFromSigPro(sig.catalog.sp)
      }
      sig.catalog <- ICAMS::as.catalog(sig.catalog,
                                       catalog.type = "counts.signature")
      ICAMS::WriteCatalog(sig.catalog,
                          paste0(seed_path, "/extracted.signatures.csv"))
      message(
        "Finished converting SigProfilerExtractor's ",
        "signature extraction TSV file into ", seed_path, "\n")
      message("---------------------")
    } # for (seedInUse in seedsInUse)
  } # for (dataset_path in datasetNames)
  invisible(return(NULL))
}

# Conversion function for all level1_directories.
move_sigpro_files_all_level1_dirs <- function(level1_dirs = level1_dirs) {
  lapply(level1_dirs, move_sigpro_files_one_dir)
  message("\n=====================")
  message("Finished moving SigPro files in all sub-directories.")
  invisible(return(NULL))
}


# Function for summaizing directory on one seed -------------------------------
extract_from_one_seed_summary <- function(summary.directory.path, 
                                          ground.truth.exposure.dir) {
  gt <- ICAMS::ReadCatalog(file.path(ground.truth.exposure.dir, "ground.truth.syn.sigs.csv"))
  ex <- ICAMS::ReadCatalog(file.path(summary.directory.path, "extracted.sigs.csv"))
  tff <- mSigTools::TP_FP_FN_avg_sim(ex, gt)
  tff$PPV <- tff$TP / (tff$TP + tff$FP)
  tff$TPR <- tff$TP / (tff$TP + tff$FN)
  return(tff)
}
# debug(SynSigEval:::SummarizeSigOneSubdir)

summarize_level1_dirs <- function(a.folder, delete.non.text = TRUE) {
  message("summarizing a.folder=", a.folder)
  stopifnot(dir.exists(a.folder))
  dataset.name.to.use <- sub("_down_samp", "", a.folder)
  message("using dataset name ", dataset.name.to.use)

  level1.results <- tibble_row(Data_set         = "",
                               Noise_level      = "",
                               Approach         = "",
                               Run              = "",
                               PPV              = -1,
                               TPR              = -1,
                               aver_Sim_TP_only = -1,
                               Composite        = -1,
                               N_Sigs           = -1,
                               FN               = -1,
                               FP               = -1,
                               FP.sigs          = list(character(0)),
                               FN.sigs          = list(character(0)))
  
  start.here <- file.path(a.folder, "raw_results")
  
  tools <- dir(start.here, pattern = "\\.results", full.names = TRUE)
  
  for (analysis.name in tools) {
    stopifnot(dir.exists(analysis.name)) # A full directory path, e.g "indel/raw_results/mSigHdp.results"
    # if (!grepl("NR_hdp_gamma_beta", x = analysis.name)) next
    message("summarizing analysis.name=", analysis.name)
    toolName <- sub(".results", "", basename(analysis.name), fixed = TRUE)
    
    datasetNames <- dir(analysis.name, full.names = TRUE)
    
    for(datasetpath in datasetNames){
      # datasetpath, e.g ""indel/raw_results/mSigHdp.results/Moderate"
      # if (!grepl("Realistic", datasetpath)) next
  
      # datasetName <- basename(datasetpath)
      noise.level <- basename(datasetpath)
      if (!noise.level %in% 
          c("Noiseless", "Moderate", "Realistic")) {
        if (dir.exists(datasetpath)) {
          message("\n\n**Skipping directory ", datasetpath, "**\n\n")
        }
        next
      }
      message("summarizing datasetpath=", datasetpath)
      ground.truth.exposure.dir <-
        file.path(dataset.name.to.use, "input", noise.level)
      message("summarizing ground.truth.exposure.dir=", ground.truth.exposure.dir)
      seedsInUse <- dir(datasetpath, pattern = "seed\\.\\d+", full.names = TRUE)
      
      for(seedInUse in seedsInUse) {
        # seedInUse e.g. "indel/raw_results/mSigHdp.results/Moderate/seed.528401"
        message("summarizing seedInUse=", seedInUse)

        if (!grepl("SignatureAnalyzer", analysis.name)) {
          
          SynSigEval::SummarizeSigOneExtrAttrSubdir(
            run.dir = seedInUse,
            ground.truth.exposure.dir = ground.truth.exposure.dir,
            summarize.exp = F,
            overwrite = T
          )
        } else {
          SynSigEval:::SummarizeSigOneSASubdir(
            run.dir = seedInUse,
            ground.truth.exposure.dir = ground.truth.exposure.dir,
            which.run = "best.run",
            summarize.exp = F,
            overwrite = T
          )
        } # else SignatureAnalyzer
        
        if (delete.non.text) {
          # browser()
          summary.path <- file.path(seedInUse,"summary")
          pdfs.to.delete <- 
            dir(summary.path, pattern = "\\.pdf", full.names = TRUE)
          if (0 != unlink(pdfs.to.delete)) {
            message("unlink of ", 
                    paste(pdfs.to.delete, collapse = " "),
                    " failed")
          }
          also.delete <- 
            dir(summary.path, 
                pattern = "assessment.sessionInfo\\.txt", 
                full.names= TRUE)
          unlink(also.delete)
        }
        
        tff <- extract_from_one_seed_summary(
          summary.directory.path    = file.path(seedInUse, "summary"),
          ground.truth.exposure.dir = ground.truth.exposure.dir)
        a.row <- tibble_row(Data_set         = dataset.name.to.use,
                            Noise_level      = noise.level,
                            Approach         = toolName,
                            Run              = basename(seedInUse),
                            PPV              = tff$PPV,
                            TPR              = tff$TPR,
                            aver_Sim_TP_only = tff$avg.cos.sim,
                            Composite        = tff$PPV + tff$TPR + tff$avg.cos.sim,
                            N_Sigs           = tff$TP + tff$FP,
                            FN               = tff$FN,
                            FP               = tff$FP,
                            FP.sigs          = list(tff$unmatched.ex.sigs),
                            FN.sigs          = list(tff$unmatched.ref.sigs))

        level1.results <- rbind(level1.results, a.row)
        
      } # for(seedInUse)
      
    } # for (datasetpath in datasetNames)
  } # for (analysis.name in tools)
  
  level1.results <- level1.results[-1, ]
  readr::write_csv(data.table::as.data.table(level1.results), file.path(a.folder, "new_all_sub_results.csv"))
  save(level1.results, file=file.path(a.folder, "level1_results.Rdata"))
  invisible(level1.results)
} # function summarize_level1_dirs

summarize_all_level1_dirs <- function()  {
  
  level1.dirs <- c("indel_set1",
                   "indel_set1_down_samp",
                   "indel_set2",
                   "indel_set2_down_samp",
                   "SBS_set1",
                   "SBS_set1_down_samp",
                   "SBS_set2",
                   "SBS_set2_down_samp")
  level1.dirs <- c(level1.dirs,
                   paste0("sens_SBS35_",
                          c(5L, 10L, 20L, 30L, 50L, 100L),
                          "_728"))
  level1.dirs <- c(level1.dirs,
                   paste0("sens_SBS35_",
                          c(5L, 10L, 20L, 30L, 50L, 100L),
                          "_1066"))
  # See function definition
  move_sigpro_files_all_level1_dirs(level1.dirs)
  
  all.out.list <- lapply(level1.dirs, summarize_level1_dirs)
  
  all.results <- do.call(rbind, all.out.list)
  
  NR.approach <- c("NR_hdp_gb_1", "NR_hdp_gb_50", "NR_hdp_gb_20")
  # Original Nicola Roberts' original hdp ALWAYS 
  # generates a noise signature hdp.0.
  # Thus we need to subtract 1 from FP
  all.results.fixed <- 
    dplyr::mutate(all.results, 
                  FP = dplyr::if_else(Approach %in% NR.approach, FP - 1, FP))
  
  foox <- dplyr::filter(all.results, !(Approach %in% NR.approach))
  foo2x <- dplyr::filter(all.results.fixed, !(Approach %in% NR.approach))
  stopifnot(all.equal(foox, foo2x)) # paranoid checking
                         
  readr::write_csv(all.results.fixed, "all_results_fixed_by_seed.csv")
  save(all.results.fixed, file = "all_results_fixed_by_seed.Rdata")
  invisible(all.results.fixed)
}

# Run wrapper function to summarize directories of all levels -----------------
all.results.fixed <- summarize_all_level1_dirs()


# development code: -----------------------------------------------------------
foo <- dplyr::filter(
  all.results.fixed,
  Data_set == "SBS_set1" & Noise_level == "Realistic" & Approach == "mSigHdp_ds_3k")
bar <- dplyr::filter(
  all.results.fixed,
  Data_set == "SBS_set1" & Noise_level == "Realistic" & Approach == "SigProfilerExtractor")
bar2 <- dplyr::filter(
  all.results.fixed, 
  Data_set == "SBS_set2" & Noise_level == "Realistic" & Approach == "SigProfilerExtractor")
bar2$FN.sigs